{
  "challenges": [
    {
      "id": "easy-1",
      "difficulty": "easy",
      "type": "whatDoesThisDo",
      "title": "Array Filter Basics",
      "code": "const numbers = [1, 2, 3, 4, 5, 6];\nconst result = numbers.filter(n => n % 2 === 0);",
      "question": "What does this code do?",
      "options": [
        "Creates an array of even numbers",
        "Creates an array of odd numbers",
        "Multiplies all numbers by 2",
        "Adds all numbers together"
      ],
      "correctAnswer": 0,
      "explanation": "The filter method creates a new array with elements that pass the test. Here, 'n % 2 === 0' checks if a number is even (divisible by 2 with no remainder).",
      "xp": 20
    },
    {
      "id": "easy-2",
      "difficulty": "easy",
      "type": "whatDoesThisDo",
      "title": "String Template",
      "code": "const name = 'Alice';\nconst greeting = `Hello, ${name}!`;",
      "question": "What will 'greeting' contain?",
      "options": [
        "Hello, ${name}!",
        "Hello, Alice!",
        "Hello, name!",
        "Error: syntax error"
      ],
      "correctAnswer": 1,
      "explanation": "Template literals (backticks) allow variable interpolation using ${variable}. The variable 'name' is replaced with its value 'Alice'.",
      "xp": 20
    },
    {
      "id": "easy-3",
      "difficulty": "easy",
      "type": "spotTheIssue",
      "title": "Missing Semicolon?",
      "code": "function greet(name) {\n  return 'Hello ' + name\n}\nconsole.log(greet('World'))",
      "question": "What's the issue with this code?",
      "options": [
        "Missing semicolons (but code works anyway)",
        "Function syntax is wrong",
        "String concatenation won't work",
        "There is no issue"
      ],
      "correctAnswer": 0,
      "explanation": "While JavaScript has automatic semicolon insertion, it's best practice to include them. This code works but could cause issues in some edge cases.",
      "xp": 20
    },
    {
      "id": "easy-4",
      "difficulty": "easy",
      "type": "whatDoesThisDo",
      "title": "Array Map",
      "code": "const prices = [10, 20, 30];\nconst discounted = prices.map(p => p * 0.8);",
      "question": "What does this code create?",
      "options": [
        "An array with 20% discounts applied",
        "An array with 80% discounts applied",
        "The total of all prices",
        "An array with prices multiplied by 8"
      ],
      "correctAnswer": 0,
      "explanation": "map() creates a new array by applying a function to each element. Multiplying by 0.8 gives 80% of the original price (20% discount).",
      "xp": 20
    },
    {
      "id": "easy-5",
      "difficulty": "easy",
      "type": "whatDoesThisDo",
      "title": "Object Destructuring",
      "code": "const user = { name: 'Bob', age: 25 };\nconst { name } = user;",
      "question": "What is the value of 'name'?",
      "options": [
        "'Bob'",
        "{ name: 'Bob', age: 25 }",
        "undefined",
        "'name'"
      ],
      "correctAnswer": 0,
      "explanation": "Destructuring extracts properties from objects. This creates a variable 'name' with the value of user.name, which is 'Bob'.",
      "xp": 20
    },
    {
      "id": "medium-1",
      "difficulty": "medium",
      "type": "spotTheIssue",
      "title": "Async Mistake",
      "code": "async function getData() {\n  const response = fetch('https://api.example.com/data');\n  const data = response.json();\n  return data;\n}",
      "question": "What's wrong with this code?",
      "options": [
        "Missing 'await' keywords before async operations",
        "fetch() is not a valid function",
        "Should use 'return await data'",
        "Nothing is wrong"
      ],
      "correctAnswer": 0,
      "explanation": "Both fetch() and response.json() return Promises. Without 'await', you're working with Promise objects instead of their resolved values. Should be: await fetch() and await response.json().",
      "xp": 30
    },
    {
      "id": "medium-2",
      "difficulty": "medium",
      "type": "modification",
      "title": "Add Error Handling",
      "code": "async function getUser(id) {\n  const response = await fetch(`/api/users/${id}`);\n  const user = await response.json();\n  return user;\n}",
      "question": "How would you add basic error handling?",
      "options": [
        "Wrap in try-catch and check response.ok",
        "Add if (error) return null",
        "Use .catch() at the end",
        "Check if (response) before json()"
      ],
      "correctAnswer": 0,
      "explanation": "Best practice: wrap async code in try-catch, check response.ok before parsing JSON, and handle different error types appropriately.",
      "xp": 30
    },
    {
      "id": "medium-3",
      "difficulty": "medium",
      "type": "whatDoesThisDo",
      "title": "Closure Example",
      "code": "function counter() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\nconst myCounter = counter();",
      "question": "What happens when you call myCounter() twice?",
      "options": [
        "Returns 1, then 2 (maintains state)",
        "Returns 1, then 1 (resets each time)",
        "Returns undefined",
        "Throws an error"
      ],
      "correctAnswer": 0,
      "explanation": "This is a closure - the inner function 'remembers' the count variable from its outer scope. Each call increments and returns the count.",
      "xp": 30
    },
    {
      "id": "medium-4",
      "difficulty": "medium",
      "type": "spotTheIssue",
      "title": "Loop Variable Scope",
      "code": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1000);\n}",
      "question": "What will this print after 1 second?",
      "options": [
        "3, 3, 3",
        "0, 1, 2",
        "undefined, undefined, undefined",
        "Nothing (error)"
      ],
      "correctAnswer": 0,
      "explanation": "'var' is function-scoped, not block-scoped. By the time setTimeout runs, the loop has finished and i = 3. Using 'let' instead would print 0, 1, 2.",
      "xp": 30
    },
    {
      "id": "medium-5",
      "difficulty": "medium",
      "type": "dependency",
      "title": "Import Statement",
      "code": "import React, { useState, useEffect } from 'react';",
      "question": "What does this import?",
      "options": [
        "React (default) plus useState and useEffect (named exports)",
        "Three separate default exports",
        "Only useState and useEffect",
        "React with methods useState and useEffect"
      ],
      "correctAnswer": 0,
      "explanation": "This imports the default export (React) and two named exports (useState, useEffect) from the 'react' library. This is standard React Hooks syntax.",
      "xp": 30
    },
    {
      "id": "hard-1",
      "difficulty": "hard",
      "type": "whatDoesThisDo",
      "title": "Array Reduce",
      "code": "const items = [{price: 10}, {price: 20}, {price: 30}];\nconst total = items.reduce((sum, item) => sum + item.price, 0);",
      "question": "What is the value of 'total'?",
      "options": [
        "60",
        "[10, 20, 30]",
        "30",
        "undefined"
      ],
      "correctAnswer": 0,
      "explanation": "reduce() accumulates values. Starting from 0, it adds each item.price: 0 + 10 + 20 + 30 = 60. The second parameter (0) is the initial value.",
      "xp": 40
    },
    {
      "id": "hard-2",
      "difficulty": "hard",
      "type": "spotTheIssue",
      "title": "React State Update",
      "code": "const [count, setCount] = useState(0);\nfunction increment() {\n  setCount(count + 1);\n  setCount(count + 1);\n}",
      "question": "If count is 0, what will it be after calling increment()?",
      "options": [
        "1 (not 2, because count is stale)",
        "2",
        "0",
        "undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Both setCount calls use the same 'count' value (0). They both set it to 1. To fix, use the function form: setCount(c => c + 1).",
      "xp": 40
    },
    {
      "id": "hard-3",
      "difficulty": "hard",
      "type": "modification",
      "title": "Debounce Function",
      "code": "function search(query) {\n  fetch(`/api/search?q=${query}`).then(handleResults);\n}\ninput.addEventListener('input', (e) => search(e.target.value));",
      "question": "How would you prevent too many API calls while typing?",
      "options": [
        "Add debouncing to delay the search function",
        "Use setTimeout(search, 500)",
        "Add if (query.length > 3) check",
        "Use setInterval instead"
      ],
      "correctAnswer": 0,
      "explanation": "Debouncing delays function execution until after a pause in events. This prevents API calls on every keystroke. Libraries like lodash provide debounce() or you can implement it with setTimeout.",
      "xp": 40
    },
    {
      "id": "hard-4",
      "difficulty": "hard",
      "type": "whatDoesThisDo",
      "title": "Spread Operator",
      "code": "const obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\nconst merged = { ...obj1, ...obj2 };",
      "question": "What is the value of merged.b?",
      "options": [
        "3 (obj2 overwrites obj1)",
        "2 (obj1 stays)",
        "[2, 3] (both values)",
        "undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Spread operator merges objects, with later properties overwriting earlier ones. obj2.b (3) comes after obj1.b (2), so merged.b = 3.",
      "xp": 40
    },
    {
      "id": "hard-5",
      "difficulty": "hard",
      "type": "dependency",
      "title": "Complex Import",
      "code": "import axios from 'axios';\nimport { format } from 'date-fns';\nimport './styles.css';",
      "question": "What is being imported here?",
      "options": [
        "axios library, format function from date-fns, and CSS styles",
        "Three npm packages",
        "Three JavaScript modules",
        "Error: can't import CSS"
      ],
      "correctAnswer": 0,
      "explanation": "Line 1: default export from axios. Line 2: named export 'format' from date-fns library. Line 3: CSS file (works in bundlers like Webpack/Vite).",
      "xp": 40
    },
    {
      "id": "expert-1",
      "difficulty": "expert",
      "type": "whatDoesThisDo",
      "title": "Promise Chain",
      "code": "Promise.resolve(5)\n  .then(x => x * 2)\n  .then(x => x + 3)\n  .then(console.log);",
      "question": "What gets logged to the console?",
      "options": [
        "13",
        "8",
        "5",
        "undefined"
      ],
      "correctAnswer": 0,
      "explanation": "Chain executes sequentially: 5 * 2 = 10, then 10 + 3 = 13. Each then() receives the return value of the previous one.",
      "xp": 50
    },
    {
      "id": "expert-2",
      "difficulty": "expert",
      "type": "spotTheIssue",
      "title": "Memory Leak",
      "code": "useEffect(() => {\n  const interval = setInterval(() => {\n    setData(fetchNewData());\n  }, 1000);\n}, []);",
      "question": "What's the problem with this React effect?",
      "options": [
        "Interval isn't cleared - creates memory leak",
        "fetchNewData() should be awaited",
        "Missing dependency in array",
        "setInterval doesn't work in React"
      ],
      "correctAnswer": 0,
      "explanation": "useEffect should return a cleanup function: return () => clearInterval(interval). Without this, intervals pile up when component re-renders or unmounts.",
      "xp": 50
    },
    {
      "id": "expert-3",
      "difficulty": "expert",
      "type": "modification",
      "title": "Race Condition",
      "code": "async function loadUser(id) {\n  setLoading(true);\n  const user = await fetchUser(id);\n  setUser(user);\n  setLoading(false);\n}",
      "question": "How would you handle rapid ID changes (race condition)?",
      "options": [
        "Use AbortController to cancel previous requests",
        "Add if (!user) check",
        "Use setTimeout to delay",
        "Check if loading before fetching"
      ],
      "correctAnswer": 0,
      "explanation": "If IDs change quickly, multiple requests race. AbortController cancels outdated requests. Also track latest request ID to ignore stale responses.",
      "xp": 50
    },
    {
      "id": "expert-4",
      "difficulty": "expert",
      "type": "whatDoesThisDo",
      "title": "Complex Destructuring",
      "code": "const data = { user: { name: 'Alice', age: 30 } };\nconst { user: { name: userName } } = data;",
      "question": "What variables are created?",
      "options": [
        "Only 'userName' (equals 'Alice')",
        "'user' and 'userName'",
        "'user', 'name', and 'userName'",
        "'data' and 'userName'"
      ],
      "correctAnswer": 0,
      "explanation": "Nested destructuring with renaming. This creates ONLY 'userName' variable (not 'user' or 'name'). It's equivalent to: const userName = data.user.name;",
      "xp": 50
    },
    {
      "id": "expert-5",
      "difficulty": "expert",
      "type": "dependency",
      "title": "Full Component",
      "code": "import React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { useQuery } from 'react-query';\nimport api from './api';",
      "question": "What dependencies does this component need?",
      "options": [
        "react, styled-components, react-query, and local api module",
        "Only React",
        "react and three npm packages",
        "Four npm packages"
      ],
      "correctAnswer": 0,
      "explanation": "Needs: react (Hooks), styled-components (CSS-in-JS), react-query (data fetching), and a local ./api module. Three are npm packages, one is a local file.",
      "xp": 50
    }
  ]
}
